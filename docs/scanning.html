<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Scanning &#8212; pyscan 1.0 documentation</title>
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.3.6/cosmo/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Utility" href="python_utility.html" />
    <link rel="prev" title="Trajectory" href="trajectory.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="_static/NetRange.png"></span>
          pyscan</a>
        <span class="navbar-text navbar-version pull-left"><b>1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="installation.html">Installation</a></li>
                <li><a href="api.html">API</a></li>
                <li><a href="examples.html">Examples</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Api</a></li>
<li class="toctree-l1"><a class="reference internal" href="point.html">Point</a></li>
<li class="toctree-l1"><a class="reference internal" href="range.html">Ranges</a></li>
<li class="toctree-l1"><a class="reference internal" href="trajectory.html">Trajectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="trajectory.html#trajectory-simplification">Trajectory Simplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="trajectory.html#trajectories-to-points">Trajectories to Points</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="#labeled-scanning">Labeled Scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="#kernelized-scanning">Kernelized Scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_utility.html">Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/BasicExample.html">Planting Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/PhillyCrime.html">Philadelphia Crime Data Example</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/PhillyCrime.html#Reading-the-Data">Reading the Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/PhillyCrime.html#Subsampling">Subsampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/PhillyCrime.html#Disk-Scanning">Disk Scanning</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/PhillyCrime.html#Rectangle-Scanning">Rectangle Scanning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/RegionSimplification.html">Region Simplification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/RegionSimplification.html#Halfplane-Compression">Halfplane Compression</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/RegionSimplification.html#Disk(or-Rectangle)-Compression">Disk(or Rectangle) Compression</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/RegionScanning.html">Region Scanning</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/RegionScanningCont.html">Region Scanning Part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/TrajectoryApproximation.html">Trajectory Approximation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryApproximation.html#Halfplane-Compression">Halfplane Compression</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryApproximation.html#Disk(or-Rectangle)-Compression">Disk(or Rectangle) Compression</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/TrajectoryPartialScanning.html">Trajectory Partial Scanning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryPartialScanning.html#Halfplane-Partial-Scanning">Halfplane Partial Scanning</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryPartialScanning.html#Disk-Partial-Scanning">Disk Partial Scanning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/TrajectoryFullScanning.html">Trajectory Full Scanning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryFullScanning.html#Halfplane-Scanning">Halfplane Scanning</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryFullScanning.html#Disk-Scanning">Disk Scanning</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples/TrajectoryFullScanning.html#Rectangle-Scanning">Rectangle Scanning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sss.html">Spatial scan statistics: approximations and performance study</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Scanning</a></li>
<li><a class="reference internal" href="#labeled-scanning">Labeled Scanning</a></li>
<li><a class="reference internal" href="#kernelized-scanning">Kernelized Scanning</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="scanning">
<span id="scanning-label"></span><h1>Scanning<a class="headerlink" href="#scanning" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="pyscan.max_halfplane">
<code class="descclassname">pyscan.</code><code class="descname">max_halfplane</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_halfplane" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of halfplanes defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in mpts and bpts. Function takes <span class="math">\(O(ns\log n)\)</span> where n is the net size and s is the size of the mpts and bts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found halfplane and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_halfplane_fast">
<code class="descclassname">pyscan.</code><code class="descname">max_halfplane_fast</code><span class="sig-paren">(</span><em>r</em>, <em>mpts</em>, <em>bpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_halfplane_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>HERE BE DRAGONS!!! This method is still experimental and somewhat broken. This method uses a different method to scan the set of potential halfplanes with respect to the fraction of points contained in mpts and bpts. This code could potentially be much faster than the standard max_halfplane method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> – Number of regions asymptopically to consider.</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found halfplane and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_halfspace">
<code class="descclassname">pyscan.</code><code class="descname">max_halfspace</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_halfspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of halfspaces defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in mpts and bpts. Function takes <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the mpts and bts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Point3s</li>
<li><strong>mpts</strong> – List of WPoint3s</li>
<li><strong>bpts</strong> – List of WPoint3s</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found halfspace and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_disk">
<code class="descclassname">pyscan.</code><code class="descname">max_disk</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of disks defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in mpts and bpts. Function takes <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the mpts and bts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found disk and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_disk_scale">
<code class="descclassname">pyscan.</code><code class="descname">max_disk_scale</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>min_res</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_disk_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of disks defined by the points in the net, between the min_res and 2 * min_res and maximizes the function disc_f with respect to the fraction of points contained in mpts and bpts. Internally we use the disk radius restriction to ignore far away points and prune out many potential disks. This can significantly decrease the amount of time the method takes to find the best region. In worst case this method will still take <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the mpts and bts, but usually runtime will be much less.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>min_res</strong> – A float that corresponds to minimum radius to consider.</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found disk and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_subgrid">
<code class="descclassname">pyscan.</code><code class="descname">max_subgrid</code><span class="sig-paren">(</span><em>grid</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_subgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the maximum subgrid exactly by enumerating all the subgrids and computing disc_f on each subgrid. Takes <span class="math">\(O(n^4)\)</span> where the grid is <span class="math">\(n \times n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grid</strong> – A Grid object</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The maximum subgrid found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_subgrid_linear">
<code class="descclassname">pyscan.</code><code class="descname">max_subgrid_linear</code><span class="sig-paren">(</span><em>grid</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_subgrid_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the maximum subgrid with respect to the linear function <span class="math">\(f(m, b) = xm + yb\)</span> exactly by using the Kadane algorithm. Takes <span class="math">\(O(n^3)\)</span> where the grid is <span class="math">\(n \times n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grid</strong> – A Grid object</li>
<li><strong>x</strong> – Double defines linear function.</li>
<li><strong>y</strong> – Double defines linear function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The maximum subgrid found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_subgrid_linear_theory">
<code class="descclassname">pyscan.</code><code class="descname">max_subgrid_linear_theory</code><span class="sig-paren">(</span><em>grid</em>, <em>r</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_subgrid_linear_theory" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds an approximate maximum subgrid with respect to the linear function <span class="math">\(f(m, b) = xm + yb\)</span> using the algorithm from <a class="reference internal" href="index.html#mp18b" id="id1">[MP18a]</a>. Takes <span class="math">\(O(n^2 + r^2 \log r)\)</span> where the grid is <span class="math">\(n \times n\)</span>.
:param grid: A Grid object
:param r: Determines how frequently to approximate the subgrids. See <a class="reference internal" href="index.html#mp18b" id="id2">[MP18a]</a> for details.
:param x: Double defines linear function.
:param y: Double defines linear function.
:rtype: The maximum subgrid found.</p>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_subgrid_convex">
<code class="descclassname">pyscan.</code><code class="descname">max_subgrid_convex</code><span class="sig-paren">(</span><em>grid</em>, <em>eps</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_subgrid_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximately finds the maximum subgrid of the grid with error eps by successively computing the maximum subgrid with respect to various linear function using the Kadane algorithm. Takes <span class="math">\(O(\frac{1}{\sqrt{\varepsilon}} n^3)\)</span> where the grid is <span class="math">\(n \times n\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grid</strong> – A Grid object</li>
<li><strong>eps</strong> – The absolute error to incur.</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The maximum subgrid found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_subgrid_convex_theory">
<code class="descclassname">pyscan.</code><code class="descname">max_subgrid_convex_theory</code><span class="sig-paren">(</span><em>grid</em>, <em>eps</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_subgrid_convex_theory" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximately finds the maximum subgrid of the grid with error eps by successively computing the maximum subgrid with respect to various linear function using the algorithm from <a class="reference internal" href="index.html#mp18b" id="id3">[MP18a]</a>. Takes <span class="math">\(O(\frac{1}{\sqrt{\varepsilon}} n^2 \log n)\)</span> where the grid is <span class="math">\(n \times n\)</span>. This method is depreciated and will be replaced shortly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grid</strong> – A Grid object</li>
<li><strong>eps</strong> – The absolute error to incur.</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The maximum subgrid found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_rectangle">
<code class="descclassname">pyscan.</code><code class="descname">max_rectangle</code><span class="sig-paren">(</span><em>mpts</em>, <em>bpts</em>, <em>eps</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_rectangle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pyscan.max_rectangle_heap">
<code class="descclassname">pyscan.</code><code class="descname">max_rectangle_heap</code><span class="sig-paren">(</span><em>mpts</em>, <em>bpts</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_rectangle_heap" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the algorithm from <a class="reference internal" href="index.html#apv06" id="id4">[APV06]</a><a class="reference internal" href="index.html#dgm95" id="id5">[DGM95]</a> to scan the data set in <span class="math">\(s^2 \log s\)</span> time. We use a Treap based rotation scheme to keep the tree balanced.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mpts</strong> – List of WPoints.</li>
<li><strong>bpts</strong> – List of WPoints.</li>
<li><strong>x</strong> – Linear parameter.</li>
<li><strong>y</strong> – Linear parameter.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">The maximum rectangle found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.ham_tree_sample">
<code class="descclassname">pyscan.</code><code class="descname">ham_tree_sample</code><span class="sig-paren">(</span><em>pts</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.ham_tree_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the list of pts and computes a ham tree sample <a class="reference internal" href="index.html#mp18a" id="id6">[MP18b]</a>. This method can shrink the size of the sample significantly while preserving the error with respect to halfplanes. This serves as a useful preprocessing step for speeding up halfplane scanning. In theory sample sizes go from <span class="math">\(O(\frac{1}{\varepsilon^2}\)</span> to <span class="math">\(O(\frac{1}{\varepsilon^{1.53..}}\log^{.766}\frac{1}{\varepsilon})\)</span> where <span class="math">\(\varepsilon\)</span> is the absolute fraction of misplaced points in a halfplane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pts</strong> – List of WPoints</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">List of WPoints</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="labeled-scanning">
<span id="labeled-scanning-label"></span><h1>Labeled Scanning<a class="headerlink" href="#labeled-scanning" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="pyscan.max_halfplane_labeled">
<code class="descclassname">pyscan.</code><code class="descname">max_halfplane_labeled</code><span class="sig-paren">(</span><em>net</em>, <em>lmpts</em>, <em>lbpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_halfplane_labeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of halfplanes defined by the points in the net and maximizes the function disc_f with respect to the labeled sets of points lmpts and lbpts. If two points with the same label are in the same region then the two points only contribute one of their weights to the region. This algorithm runs in time <span class="math">\(O(ns \log n)\)</span> where n is the net size and s is the size of the lmpts and lbpts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of LPoints</li>
<li><strong>bpts</strong> – List of LPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found halfplane and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_halfspace_labeled">
<code class="descclassname">pyscan.</code><code class="descname">max_halfspace_labeled</code><span class="sig-paren">(</span><em>net</em>, <em>lmpts</em>, <em>lbpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_halfspace_labeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of halfspaces defined by the points in the net and maximizes the function disc_f with respect to the labeled sets of points lmpts and lbpts. If two points with the same label are in the same region then the two points only contribute one of their weights to the region. This algorithm runs in time <span class="math">\(O(n^2s \log n)\)</span> where n is the net size and s is the size of the lmpts and lbpts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Point3s</li>
<li><strong>mpts</strong> – List of LPoint3s</li>
<li><strong>bpts</strong> – List of LPoint3s</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found halfspace and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_disk_labeled">
<code class="descclassname">pyscan.</code><code class="descname">max_disk_labeled</code><span class="sig-paren">(</span><em>net</em>, <em>lmpts</em>, <em>lbpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_disk_labeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of disks defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in lmpts and lbpts. Points with identical labels are not double counted if they are contained in the same region. In worst case this method will still take <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the lmpts and lbts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>lmpts</strong> – List of LPoints</li>
<li><strong>lbpts</strong> – List of LPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found disk and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_disk_scale_labeled">
<code class="descclassname">pyscan.</code><code class="descname">max_disk_scale_labeled</code><span class="sig-paren">(</span><em>net</em>, <em>lmpts</em>, <em>lbpts</em>, <em>compress</em>, <em>min_res</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_disk_scale_labeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of disks defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in lmpts and lbpts. Only considers disks with radii between min_res and 2 * min_res. This method internally maps the disk scanning problem to halfplane scanning. Using this mapping we can compress sets of points with the same labels. This compression step can significantly improve the runtime and doesn’t incurr any extra error. In worst case this method will still take <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the lmpts and lbts, but in practice this method should be much faster than this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>lmpts</strong> – List of LPoints</li>
<li><strong>lbpts</strong> – List of LPoints</li>
<li><strong>compress</strong> – Turns the compression step on or off.</li>
<li><strong>min_res</strong> – Defines the radius range to consider.</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found disk and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_disk_scale_labeled_alt">
<code class="descclassname">pyscan.</code><code class="descname">max_disk_scale_labeled_alt</code><span class="sig-paren">(</span><em>net</em>, <em>lmpts</em>, <em>lbpts</em>, <em>min_res</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_disk_scale_labeled_alt" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of disks defined by the points in the net and maximizes the function disc_f with respect to the fraction of points contained in lmpts and lbpts. Only considers disks with radii between min_res and 2 * min_res. This method internally directly scans disks and lacks the compression step found in the previous algorihtm, so it is slighlty slower in practice then the previous method with compression turned off.  In worst case this method will still take <span class="math">\(O(n^2s\log n)\)</span> where n is the net size and s is the size of the lmpts and lbts, but in practice this method should be much faster than this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>lmpts</strong> – List of LPoints</li>
<li><strong>lbpts</strong> – List of LPoints</li>
<li><strong>min_res</strong> – Defines the radius range to consider.</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><p>Tuple of the found disk and the maximum disc_f value</p>
<p>py::def(“max_rect_labeled”, &amp;pyscan::max_rect_labeled);</p>
<p>py::def(“max_rect_labeled_scale”, pyscan::max_rect_labeled_scale);</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_rect_labeled">
<code class="descclassname">pyscan.</code><code class="descname">max_rect_labeled</code><span class="sig-paren">(</span><em>r</em>, <em>max_width</em>, <em>lmpts</em>, <em>lbpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_rect_labeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans an approximate set of rectangles smaller than max_width in lmpts and lbpts by using a grid where each row and column of the grid can have at most <span class="math">\(1/r\)</span> fraction of the total weight.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> – integer</li>
<li><strong>max_width</strong> – double</li>
<li><strong>lmpts</strong> – List of LPoints</li>
<li><strong>lbpts</strong> – List of LPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found rectangle and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_rect_labeled_scale">
<code class="descclassname">pyscan.</code><code class="descname">max_rect_labeled_scale</code><span class="sig-paren">(</span><em>r</em>, <em>max_width</em>, <em>alpha</em>, <em>lmpts</em>, <em>lbpts</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_rect_labeled_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a regular sparse grid of size <span class="math">\(1/alpha \times 1/alpha\)</span> and then considers subgrids of max_width size containing a large enough fraction of points to be worth scanning. On these small subgrids  this method constructs a new grid such that each row and column of this grid can have at most <span class="math">\(1/r\)</span> fraction of the total weight and then scans ever subgrid of this new grid. This method is usually faster than the previous method, but introduces some spatial error <span class="math">\(\alpha\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> – integer</li>
<li><strong>alpha</strong> – double</li>
<li><strong>max_width</strong> – double</li>
<li><strong>lmpts</strong> – List of LPoints</li>
<li><strong>lbpts</strong> – List of LPoints</li>
<li><strong>disc_f</strong> – Discrepancy function to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of the found rectangle and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="kernelized-scanning">
<span id="smooth-scanning-label"></span><h1>Kernelized Scanning<a class="headerlink" href="#kernelized-scanning" title="Permalink to this headline">¶</a></h1>
<p>These methods use different scan statistics than the purely combinatorial versions.</p>
<dl class="function">
<dt id="pyscan.gaussian_kernel">
<code class="descclassname">pyscan.</code><code class="descname">gaussian_kernel</code><span class="sig-paren">(</span><em>bandwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.gaussian_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a gaussian kernel to be used with the smooth scanning function of form <span class="math">\(1/\sqrt{2 \pi} \exp(-u^2/(2 b^2))\)</span> where b is bandwidth.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bandwidth</strong> – double (kernel bandwidth)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.Bernouli_K">
<code class="descclassname">pyscan.</code><code class="descname">Bernouli_K</code><span class="sig-paren">(</span><em>kernel</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.Bernouli_K" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a discrepancy object that can be used to scan in the smooth scanning functions. The kernel parameter defines how distance is measured and
how the bandwidth is determined.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>kernel</strong> – The kernel used to determine distance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_annuli">
<code class="descclassname">pyscan.</code><code class="descname">max_annuli</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>radii</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_annuli" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of annuli with radii defined by radii and the points in the net. For each annuli we maximizes the function disc_f with respect to the mpts and bpts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>min_res</strong> – A float that corresponds to minimum radius to consider.</li>
<li><strong>disc_f</strong> – KDisc object to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of a disk of radius equal to radii[-1] centered at the annuli and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_annuli_scale">
<code class="descclassname">pyscan.</code><code class="descname">max_annuli_scale</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>radii</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_annuli_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of annuli with radii defined by radii and the points in the net. For each annuli we maximizes the function disc_f with respect to the mpts and bpts. This version ignores far away
points, so in theory can be much faster than the previous version.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>min_res</strong> – A float that corresponds to the radius to consider.</li>
<li><strong>disc_f</strong> – KDisc object to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of a disk of radius equal to radii[-1] centered at the annuli and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyscan.max_annuli_scale_multi">
<code class="descclassname">pyscan.</code><code class="descname">max_annuli_scale_multi</code><span class="sig-paren">(</span><em>net</em>, <em>mpts</em>, <em>bpts</em>, <em>res_scales</em>, <em>max_radii</em>, <em>disc_f</em><span class="sig-paren">)</span><a class="headerlink" href="#pyscan.max_annuli_scale_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the set of annuli with radii less than max_radii. The algorithm uses the res_scales to define levels in the annuli for approximating the kernel values. For each annuli we maximizes the
function disc_f with respect to the mpts and bpts. This version ignores far away points and uses a more efficient method for scanning all the annuli. In theory the runtime of this method should
be as good or even better than the previous algorithm, but in practice is probably slightly slower.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>net</strong> – List of Points</li>
<li><strong>mpts</strong> – List of WPoints</li>
<li><strong>bpts</strong> – List of WPoints</li>
<li><strong>res_scales</strong> – A list of floats that correspond to the relative sizes of the different annuli.</li>
<li><strong>max_radii</strong> – A float that corresponds to the maximum radius to consider. This will relate to the bandwidth of the kernel used.</li>
<li><strong>disc_f</strong> – KDisc object to maximize over.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Tuple of a disk of radius equal to radii[-1] centered at the annuli and the maximum disc_f value</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/scanning.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2019, Michael Matheny.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.<br/>
    </p>
  </div>
</footer>
  </body>
</html>